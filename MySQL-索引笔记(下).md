---
title: MySQL-索引笔记(下)
date: 2019-10-19 19:01:15
tags: ["MySQL"]
categories: "MySQL"
---

# MySQL-索引笔记(下)

在上面一个笔记中学习了InnoDB索引的数据结构模型和索引维护的相关知识

那么这一篇继续来深入了解索引

我们先来看这一个问题:

在下面这个表T中，如果我执行 

```mysql
select * from T where k between 3 and 5
```

需要执行几次树的搜索操作，会扫描多少行？

```mysql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

![](https://raw.githubusercontent.com/catwithtudou/photo/master/20191019184251.png)

- 这条SQL查询语句的执行流程
  1. 在k索引树上找到k=3的记录，取得 ID = 300；
  2. 再到ID索引树查到ID=300对应的R3；
  3. 在k索引树取下一个值k=5，取得ID=500；
  4. 再回到ID索引树查到ID=500对应的R4；
  5. 在k索引树取下一个值k=6，不满足条件，循环结束。

可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），因为查询结果的数据只在主键索引下有所以就回表了两次（步骤2和4）

那么，有没有可能经过索引优化，**尽量避免回表过程**呢？

## 覆盖索引

如果执行的语句是

```mysql
select ID from T where k between 3 and 5
```

这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。

在这个查询里面，**索引k已经“覆盖了”我们的查询需求**，我们称为**覆盖索引**。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段**

> 需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2

在日常工作中如果有高频查询的请求,假如是根据工号查询姓名,虽然在工号上面建立索引就足够了,但是根据工号和姓名建立一个联合索引,这个联合索引就可以不再需要回表查整行记录,减少语句的执行时间

但是维护索引字段也是有一定的代价,这就需要你权衡考虑了

## 最左前缀原则

**B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。**

比如下面的(name,age)联合索引来分析

![](https://raw.githubusercontent.com/catwithtudou/photo/master/20191019185702.png)

索引项根据索引定义里面出现的字段顺序排序

可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。

基于上面对最左前缀索引的说明，那么**在建立联合索引的时候，如何安排索引内的字段顺序?**

这里我们的评估标准是，**索引的复用能力**

比如有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了

因此，**第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。**

接下来考虑原则便是**空间**

而空间则关注于a,b字段的大小,若a比较大,那么可以创建一个(a,b)和(b)索引

## 索引下推

在MySQL 5.6之前，只能从第一个索引字段开始一个个回表。到主键索引上找出数据行，再对比字段值

而MySQL 5.6 引入的索引下推优化（index condition pushdown)，

**可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。**

- 无索引下推的流程

  ![](https://raw.githubusercontent.com/catwithtudou/photo/master/20191019190202.png)

- 有索引下推的流程

  ![](https://raw.githubusercontent.com/catwithtudou/photo/master/20191019190230.png)

## 问题

实际上主键索引也是可以使用多个字段的。DBA小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：

```mysql
CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

公司的同事告诉他说，由于历史原因，这个表需要a、b做联合主键，这个小吕理解了。

但是，学过本章内容的小吕又纳闷了，既然主键包含了a、b这两个字段，那意味着单独在字段c上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？

同事告诉他，是因为他们的业务里面有这样的两种语句：

```mysql
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
```

问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？

### 答案

如果c列上重复率很低的情况下,两个索引都可以不用建。因为如果过滤只剩下几条数据,排序也不影响
如果c列重复度比较高,就需要建立(c,b)的联合索引了,来消除排序了。因为在数据量大的情况下,排序是一个非常耗时的操作,
很有可能还需要磁盘临时表来做排序。而且如果没有(c,b)联合索引,limit 1仅仅表示返回给客户端一条数据,没有起到限制扫描行数的作用
ca列上的索引,由于满足最左前缀,不用加。因为c是固定值,那么a列就是有序的.那么这里limit 1就很好限制了只用精准扫描一条数据.
所以有时候如果在where条件建立索引的效率差的情况下,在order by limit这一列建索引也是很好的方案,排好序,在回表,只要过滤出满足条件的limit行,就能及时停止扫描

## 参考

<https://time.geekbang.org/column/intro/139>